"use strict";(self.webpackChunksol_2_ink=self.webpackChunksol_2_ink||[]).push([[495],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,k=p["".concat(s,".").concat(m)]||p[m]||d[m]||i;return n?r.createElement(k,a(a({ref:t},u),{},{components:n})):r.createElement(k,a({ref:t},u))}));function k(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:o,a[1]=l;for(var c=2;c<i;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},942:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const i={sidebar_position:5,title:"Parsing functions"},a=void 0,l={unversionedId:"how_it_works/parsing_functions",id:"how_it_works/parsing_functions",title:"Parsing functions",description:"All parsed functions may include Statement enum variant from Solang. We need to convert this to Sol2Ink Statement, so it is more suitable for the ink! contract generation. We do this to ease some steps in the code generation, as well as to actually easily build the output code from these inputs. We will go over some remarkable points regarding the functions parsing.",source:"@site/docs/how_it_works/parsing_functions.md",sourceDirName:"how_it_works",slug:"/how_it_works/parsing_functions",permalink:"/how_it_works/parsing_functions",draft:!1,editUrl:"https://github.com/727-Ventures/sol2ink/tree/main/docs/docs/how_it_works/parsing_functions.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Parsing functions"},sidebar:"tutorialSidebar",previous:{title:"Parsing a contract",permalink:"/how_it_works/parsing_contract"},next:{title:"Parsing expressions",permalink:"/how_it_works/parsing_expressions"}},s={},c=[{value:"Return statement",id:"return-statement",level:3},{value:"Require",id:"require",level:3},{value:"Emit event",id:"emit-event",level:3},{value:"Ternary operator",id:"ternary-operator",level:3},{value:"Binary operation",id:"binary-operation",level:3},{value:"Loops",id:"loops",level:3},{value:"Unchecked blocks",id:"unchecked-blocks",level:3},{value:"Try/catch blocks",id:"trycatch-blocks",level:3},{value:"Assembly blocks",id:"assembly-blocks",level:3}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"All parsed functions may include ",(0,o.kt)("inlineCode",{parentName:"p"},"Statement")," enum variant from Solang. We need to convert this to Sol2Ink ",(0,o.kt)("inlineCode",{parentName:"p"},"Statement"),", so it is more suitable for the ink! contract generation. We do this to ease some steps in the code generation, as well as to actually easily build the output code from these inputs. We will go over some remarkable points regarding the functions parsing."),(0,o.kt)("h3",{id:"return-statement"},"Return statement"),(0,o.kt)("p",null,"The mission is simple - to return a value. The functions of the generated contract will always return ",(0,o.kt)("inlineCode",{parentName:"p"},"Result<T, Error>"),", where ",(0,o.kt)("inlineCode",{parentName:"p"},"T")," is the return type of the function (",(0,o.kt)("inlineCode",{parentName:"p"},"()")," if the function has no return type). We wrap the output in a result because if we want to revert a call, we need to return an error. And that is, of course, possible if we return ",(0,o.kt)("inlineCode",{parentName:"p"},"Result"),". The error type returned in the Result is declared in the final contract, but more on that later."),(0,o.kt)("h3",{id:"require"},"Require"),(0,o.kt)("p",null,"Require statements are not available in Rust and ink!, so Sol2Ink will parse them as an if statement and return an error. But the require statement requires the condition to be true, so Sol2Ink will parse it as an inverted condition. Meaning ",(0,o.kt)("inlineCode",{parentName:"p"},"require(true)")," will be parsed as "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Rust"},"if !(true) {\n    return Err(Error(String::new()))\n}\n")),(0,o.kt)("p",null,"If the error message was defined in the Solidity contract, Sol2Ink will use this error message in the ink! contract as well, but if it was not provided, Sol2Ink will provide its own error message. Future versions of Sol2Ink will produce a nicer inverted conditions (so ",(0,o.kt)("inlineCode",{parentName:"p"},"require(true)")," will produce ",(0,o.kt)("inlineCode",{parentName:"p"},"if false")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"if !(true)"),"). We work on a better experience and better code generation."),(0,o.kt)("h3",{id:"emit-event"},"Emit event"),(0,o.kt)("p",null,"Here we need to note that events in ink! are structs with the ",(0,o.kt)("inlineCode",{parentName:"p"},"ink[(event)]")," attribute. So emitting an event is just calling of ",(0,o.kt)("inlineCode",{parentName:"p"},"emit_event")," function, providing a new struct with the desired parameters."),(0,o.kt)("h3",{id:"ternary-operator"},"Ternary operator"),(0,o.kt)("p",null,"The ternary operator does not exist in Rust, so they are parsed as an if/else block."),(0,o.kt)("h3",{id:"binary-operation"},"Binary operation"),(0,o.kt)("p",null,"Binary operations ++ and -- are not available in Rust, so we parse them as addition or subtraction of 1. Depending on if the operation were a prefix or suffix operation, we would do the incrementation/subtraction before or after reading the value."),(0,o.kt)("h3",{id:"loops"},"Loops"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"For loops are parsed to while loops, with the incrementation happening at the end of the loop. "),(0,o.kt)("li",{parentName:"ul"},"Do/while loops are parsed as a loop with a condition check at the end of the block. "),(0,o.kt)("li",{parentName:"ul"},"While loops are parsed as while loops ")),(0,o.kt)("h3",{id:"unchecked-blocks"},"Unchecked blocks"),(0,o.kt)("p",null,"Unchecked blocks are parsed as normal code blocks."),(0,o.kt)("h3",{id:"trycatch-blocks"},"Try/catch blocks"),(0,o.kt)("p",null,"We will call the call from try, and check if the result is an error. If yes, we will return an error."),(0,o.kt)("h3",{id:"assembly-blocks"},"Assembly blocks"),(0,o.kt)("p",null,"Sol2Ink puts a comment about missing assembly block. We plan on implementing parsing of assembly block in the future."),(0,o.kt)("p",null,"All other statements are parsed as expected:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"declarations"),(0,o.kt)("li",{parentName:"ul"},"comments"),(0,o.kt)("li",{parentName:"ul"},"conditional blocks and one-line conditions"),(0,o.kt)("li",{parentName:"ul"},"assignments"),(0,o.kt)("li",{parentName:"ul"},"function calls")))}d.isMDXComponent=!0}}]);