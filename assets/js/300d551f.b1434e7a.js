"use strict";(self.webpackChunksol_2_ink=self.webpackChunksol_2_ink||[]).push([[470],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),h=r,m=p["".concat(s,".").concat(h)]||p[h]||d[h]||a;return n?i.createElement(m,o(o({ref:t},u),{},{components:n})):i.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<a;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8546:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=n(7462),r=(n(7294),n(3905));const a={sidebar_position:2,title:"Building the ink! smart contract"},o=void 0,l={unversionedId:"tutorial/building",id:"tutorial/building",title:"Building the ink! smart contract",description:"To build the ink! smart contract we will need cargo-contract. Note that the generated contracts use ink! version 3.4.0, so we will need to have cargo-contract version 1.5.1 installed. So if we satisfy this condition, we will navigate to the generated folder generated/contracts/erc_20 and call cargo contract build. The contract will start building; we will wait for a while and...",source:"@site/docs/tutorial/building.md",sourceDirName:"tutorial",slug:"/tutorial/building",permalink:"/sol2ink/tutorial/building",draft:!1,editUrl:"https://github.com/727-Ventures/sol2ink/tree/main/docs/docs/tutorial/building.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Building the ink! smart contract"},sidebar:"tutorialSidebar",previous:{title:"Preparation",permalink:"/sol2ink/tutorial/preparation"},next:{title:"Parsing",permalink:"/sol2ink/how_it_works/parsing"}},s={},c=[{value:"Warnings",id:"warnings",level:3},{value:"More things to notice",id:"more-things-to-notice",level:3}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"To build the ink! smart contract we will need ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/cargo-contract"},"cargo-contract"),". Note that the generated contracts use ink! version 3.4.0, so we will need to have ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo-contract")," version ",(0,r.kt)("inlineCode",{parentName:"p"},"1.5.1")," installed. So if we satisfy this condition, we will navigate to the generated folder ",(0,r.kt)("inlineCode",{parentName:"p"},"generated/contracts/erc_20")," and call cargo contract build. The contract will start building; we will wait for a while and..."),(0,r.kt)("p",null,"It fails! So let's look at the issue."),(0,r.kt)("p",null,"The first issue looks like this:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/43150707/216478364-737a042a-bfde-4061-b879-0e11f8e46b64.png",alt:"issue0"})),(0,r.kt)("p",null,"The original code said ",(0,r.kt)("inlineCode",{parentName:"p"},"_balances[account] = accountBalance - amount;"),", and Sol2Ink transpiled it as ",(0,r.kt)("inlineCode",{parentName:"p"},"self.data().balances.insert(&(account), &account_balance - amount);"),", forgetting to put the argument of insert into parenthesis. We will ewritw it to ",(0,r.kt)("inlineCode",{parentName:"p"},"self.data().balances.insert(&(account), &(account_balance - amount));")," (adding parenthesis), and the issue is gone."),(0,r.kt)("p",null,"Another issue will look like this:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/43150707/216478810-85683b50-a944-435c-89dc-fb6c72266209.png",alt:"issue1"})),(0,r.kt)("p",null,"The Solidity expression ",(0,r.kt)("inlineCode",{parentName:"p"},"type(uint256).max")," is parsed as ",(0,r.kt)("inlineCode",{parentName:"p"},"type_of(u128)?.max"),". The correct form is ",(0,r.kt)("inlineCode",{parentName:"p"},"u128::MAX"),", so we will rewrite it to that form. And try to build."),(0,r.kt)("p",null,"And we failed again."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/43150707/216479049-fdc2359b-1eb1-462d-ace6-3d0f4ded5074.png",alt:"issue2"})),(0,r.kt)("p",null,"These issues have the same reason; we want to return a String which is the type that can not be copied. Fixing both of these issues is simple; we will return the clones of these strings by calling ",(0,r.kt)("inlineCode",{parentName:"p"},".clone()")," on them. "),(0,r.kt)("p",null,"The last issues:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/43150707/216480272-4d8c9546-1ccc-4164-bd42-7c7868aa960d.png",alt:"issue3"})),(0,r.kt)("p",null,"These occur because the original contract has some bases, which we did not provide, but Sol2Ink assumed we did, so it tried to implement them for the contract. We will just remove these line from the contract. Now when we build, everything works! Congratulations!"),(0,r.kt)("h3",{id:"warnings"},"Warnings"),(0,r.kt)("p",null,"You could have noticed some warnings. The cause of these warnings is that Sol2Ink implicitly sets all variables as mutable, even if we do not mutate them, so we will simply remove the ",(0,r.kt)("inlineCode",{parentName:"p"},"mut")," keyword on the highlighted places. Also, there are some functions, which have parameters that are unused inside that function. It is not an issue, but if we want to remove these warnings, we will add ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," to the front of the names of these parameters (or rename them to ",(0,r.kt)("inlineCode",{parentName:"p"},"_"),"), implying that those parameters are unused. "),(0,r.kt)("h3",{id:"more-things-to-notice"},"More things to notice"),(0,r.kt)("p",null,"Sol2Ink is able to parse most of the Solidity contracts, however, there may be some code which we did not have the chance to cover properly yet. It will be parsed, but there is a way in ink! on how to handle these cases specifically. We are working on it to make Sol2Ink even more usable and we will cover them in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Known issues")," section. And that's it! Now it is the developer's job to optimize the contract for Rust and ink!, but the dirty work is already behind us!"))}d.isMDXComponent=!0}}]);